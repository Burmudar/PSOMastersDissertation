
<H1><A NAME="SECTION05160000000000000000"><tex2html_anchor_invisible_mark></A>
<A NAME="sec:keepinghistory"><tex2html_anchor_mark></A><BR>
Keeping History
</H1>
In the traditional <#5820#>PSO<#5820#> history is kept by using the particle personal best position to direct the next movement of the particle. Other methods such as inertia also allow history to direct the movement of the particle. With regard to the developed <#5821#>PSO<#5821#> on the <#5822#>FAP<#5822#>, the algorithm also uses these concepts. But these concepts are not able to effectively exploit the history of a particle since they have no concept of what combinations of frequency values have previously been used in a cell.

<P>
In the <#5823#>FAP<#5823#> <#5824#>PSO<#5824#> algorithm more historical information is kept. The algorithm accomplishes this by incorporating the concept of tabu lists from the <#5825#>TS<#5825#> algorithm. Using tabu lists a particle will be able to better exploit the problem space it currently finds itself in. In the <#5826#>FAP<#5826#> <#5827#>PSO<#5827#> algorithm, tabu lists were incorporated by adding to each cell a list which keeps track of each frequency value that has been assigned to the transceivers in the cell for 20 iterations.

<P>
Initially the <#5828#>FAP<#5828#> <#5829#>PSO<#5829#> algorithm calculated the velocity of a particle and then applied this to the current position of the particle. This moved the particle to its next position in the problem space. With tabu lists this movement step becomes more complicated.

<P>
Tabu lists are there to prevent cycling of movements to the same position. Thus to stop the particle from moving to a position that was previously occupied, an extra check has to occur before the particle can occupy a new position. As can be seen in the two developed velocity methods in algorithms~<A HREF=<tex2html_cr_mark>#alg:velocitymethod1#5830><tex2html_cr_mark></A> and <A HREF=<tex2html_cr_mark>#alg:velocitymethod2#5831><tex2html_cr_mark></A> the last step that occurs in both algorithms is that the SanitizePosition method is called.

<P>
The SanitizePosition method is listed in algorithm~<A HREF=<tex2html_cr_mark>#alg:sanitizeposition#5832><tex2html_cr_mark></A>. Within this algorithm a particle's future position is first checked and sanitised before the particle is allowed to move to that position. The main purpose of this algorithm is to check if the future position has been occupied previously and hence is in the tabu list.
<BR>
<A NAME="alg:sanitizeposition"><tex2html_anchor_mark></A><tex2html_image_mark>#algorithm5833#
<BR>

<P>
In the <#5840#>FAP<#5840#> <#5841#>PSO<#5841#> the tabu list check works slightly differently from what one would expect. As can be observed in algorithm~<A HREF=<tex2html_cr_mark>#alg:sanitizeposition#5842><tex2html_cr_mark></A>, it enters a loop which iterates through all the cells in the position of the particle. Note that the position passed to the SanitizePosition algorithm is a <I>future</I> position; thus the particle does not yet occupy the position yet. Within the for-loop in line 2 the method <I>ResolveCollision</I> is called which is listed in algorithm~<A HREF=<tex2html_cr_mark>#alg:resolvecollision#5845><tex2html_cr_mark></A>.

<P>
<BR>
<A NAME="alg:resolvecollision"><tex2html_anchor_mark></A><tex2html_image_mark>#algorithm5846#
<BR>

<P>
As can be observed in algorithm~<A HREF=<tex2html_cr_mark>#alg:resolvecollision#5855><tex2html_cr_mark></A>, when a frequency value is found to exist in the tabu list a collision is said to occur. In the <#5856#>FAP<#5856#> <#5857#>PSO<#5857#> a collision means that the specific frequency value that has been assigned to a transceiver for a particular cell was found in the tabu list. Once a collision occurs, the algorithm tries to generate a new random frequency that can be assigned to the transceiver as can be seen to occur within the while-loop in lines 2 -- 3.

<P>
The algorithm generates a new random frequency value and then checks to see if the generated value collides with the tabu list. If collision still occurs, the algorithm will generate another random frequency. As long as a collision occurs the algorithm will continually generate a new random frequency until it has attempted 20 random frequencies with no frequency colliding. 

<P>
After 20 attempts the algorithm just accepts the last generated frequency as the new frequency. The maximum number of 20  attempts was selected through testing and can be increased at the expense of more computational time. 

<P>
The resolution of collisions can be seen as a mechanism to increase the exploration of the <#5858#>PSO<#5858#> algorithm as well as to increase the diversity. By making certain frequency assignments to transceivers tabu the algorithm is forced to try new frequency assignments and thus explore more of the problem space.

<P>
Care must be taken to select a maximum size of the tabu List since one wants to keep enough history so that the problem space can be adequately exploited. The maximum tabu List size must be less than the number of available frequencies otherwise the algorithm will not be allowed to make any assignments. 

<P>
Finally the maximum tabu List cannot be too large, since the checks the algorithm has to do to see if a value is tabu are very expensive. The operation is expensive, since the tabu list needs to be iterated through for each potential value to see if the frequency value is tabu.

<P>
By incorporating tabu lists and the collision resolving procedure, the efficiency of the algorithm reduces dramatically. To increase efficiency of the operations in the algorithm, the <#5859#>FAP<#5859#> <#5860#>PSO<#5860#> algorithm utilises parallelisation. Since the collision resolving procedure is very expensive it was one of the first operations to be parallelised. Other procedures that were also parallelised to increase efficiency were the velocity and any other procedures which involved constraint checks.

<P>
By parallelising these operations the efficiency of the algorithm increased and it was able to produce results significantly faster. This is because parallelisation is a good fit to the now standard multicore CPUs in desktop computers.

<P>
With the parallelisation of the procedures a slight side effect was noticed. The randomness of the random number generator decreased. This effect was noticed because during testing the counter variable of the collision resolver was displayed on the console. When the value was being displayed on the console the <#5861#>FAP<#5861#> <#5862#>PSO<#5862#> algorithm produced much better results. 

<P>
The reason for this is that outputting the variable inherently introduces a delay and therefore the random number generators in other threads have different seed values. Hence with a delay in each parallel thread the numbers generated by the random number generator are more distinct. 

<P>
Due to how parallel threads are scheduled by the operating system, some threads might start off with similar seed values because in  the <#5863#>FAP<#5863#> <#5864#>PSO<#5864#> algorithm the current time is used as a seed value<A NAME="tex2html30"
  HREF="footnode.html#foot5865"><SUP>6.6</SUP></A>.

<P>
Keeping the delay counter variable displayed on the console introduced a delay in the collision resolving procedure. The reason the particular procedure was selected was that it was where the effect of delay was first noticed. After performing tests with delays of 5 milliseconds (ms), 10 ms, 15 and 20 it was found that 20 ms was the best-suited delay, as it gave just enough time for a reasonable distinction to be made between seed values used by other parallel threads.

<P>
In this section a discussion was presented on how the <#5866#>FAP<#5866#> <#5867#>PSO<#5867#> keeps additional history. The reason why the <#5868#>FAP<#5868#> <#5869#>PSO<#5869#> needs to keep more history was discussed as well as what mechanism the algorithm uses to store this information, namely tabu lists. Also covered was how the algorithm deals with collisions, which occurs when positions are in the tabu list. Finally collision resolution was explained with the aid of pseudocode of the algorithm that is utilised.

<P>
