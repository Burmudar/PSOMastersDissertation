
<H3><A NAME="SECTION04442200000000000000">
Neighbourhood Search</A>
</H3>
The following discussion on neighbourhood search is not meant to be an exhaustive survey on the different methods and how they differ under different problems. Instead the discussion is ment as a general overview to get an idea of neighborhood generation in the <#2522#>TS<#2522#> algorithm context. 

<P>
The following neighbourhood discussion will be based on the assumption that the underlying problem the <#2523#>TS<#2523#> is applied to, has a search space with defined boundaries that is suitable for neighborhood generation.

<P>
TS uses a neighbourhood local search process to explore the solution space. There is no set process of how neighbourhood candidate solutions are selected as it is problem dependant. The overall quality of the solution produced by <#2524#>TS<#2524#> is also dependent on the neighbourhood search strategy used [#TSHazardous#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. 

<P>
The neighbourhood search phase is the first operation performed after the algorithm has been initialised, which is to say the algorithm has generated an initial starting solution from which the exploration process can start.

<P>
The neighbourhood search phase is the primary means for the <#2526#>TS<#2526#> algorithm to search the solution space for an optimal solution. It is within this phase that new possible solutions must be presented for the <#2527#>TS<#2527#> heuristic to allow the algorithm to decide to which solution it must move next.

<P>
The new possible solutions that are generated are called neighbouring solutions; hence the <#2528#>TS<#2528#> algorithm always moves to a neighbouring solution. When the <#2529#>TS<#2529#> algorithm moves to a neighbouring solution, the current solution is replaced by the neighbouring solution. Therefore, in the next iteration, neighbours for the new solution need to be generated.

<P>
Generation of new neighbours can range from a simple increment option to a complex operation that incorporates additional intelligence by means of a more heuristic approach to generate new neighbours.

<P>
The <#2530#>TS<#2530#> algorithm is not limited to just one neighbourhood search strategy. In the research by Gopalakrishnan et al.[#TabuCarryOver#<tex2html_cite_mark>#1##<tex2html_cite_mark>#] five neighbourhood move strategies are developed and are used interchangeably; in some cases a strategy is used three times in a row due to stagnation in the search space. 

<P>
Stagnation occurs when the algorithm does not move to a better solution; instead it opts to stay on the current solution, as no neighbouring solution is better than the current one. 

<P>
Other neighbourhood strategies developed is that by N. A. Wassan [#ReactiveTabuVHR#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. Wassan used a neighbourhood selection strategy that exchanges route nodes from initial vehicle routes for the vehicle routing problem. This route exchange enables the <#2533#>TS<#2533#> algorithm to search much more broadly due to the constant supply of different solutions. 

<P>
Since initial solutions are constantly modified, it enables the <#2534#>TS<#2534#> procedure to be a very fined-grained process, because often a small change in a potential solution can have a big impact on the overall proposed solution by the <#2535#>TS<#2535#> algorithm.

<P>
In the research done by Zhang et al.[#TSHazardous#<tex2html_cite_mark>#1##<tex2html_cite_mark>#] a neighbourhood selection scheme called <I>dynamic penalty</I> is developed. When the algorithm moves onto an infeasible solution a penalty is imposed. By dynamically changing the penalty that is imposed the ``feasibility'' of solutions produced is influenced. 

<P>
Therefore, if and when the algorithm continually produces infeasible solutions, the penalty imposed is increased to guide the algorithm to produce more feasible solutions. Finally, when the algorithm becomes trapped at local optima, the penalty is reduced, which allows the algorithm to consider moving onto infeasible solutions thus escaping local optima.

<P>
TS is an iterative algorithm, executing a set of operations sequentially until a stopping criterion is met[#EvoParallelTabu#<tex2html_cite_mark>#1##<tex2html_cite_mark>#,#TabuVechicleRoutingWithTimeWindows#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. At each iteration the algorithm has to determine feasibility of the immediate neighbourhood candidate solutions [#EvoParallelTabu#<tex2html_cite_mark>#1##<tex2html_cite_mark>#,#TabuVechicleRoutingWithTimeWindows#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. 

<P>
Therefore each candidate must be evaluated by some function, which may be a costly operation in terms of computational cycles as well as in terms of time[#EvoParallelTabu#<tex2html_cite_mark>#1##<tex2html_cite_mark>#,#TabuVechicleRoutingWithTimeWindows#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. This constant evaluation can drastically reduce the overall performance of the algorithm, since it is spending more time calculating feasibility than actually searching the solution space [#EvoParallelTabu#<tex2html_cite_mark>#1##<tex2html_cite_mark>#,#TabuVechicleRoutingWithTimeWindows#<tex2html_cite_mark>#1##<tex2html_cite_mark>#]. 

<P>
